datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DATABASE_URL_UNPOOLED")
}

generator client {
  provider = "prisma-client-js"
}

// ============================================
// ENUMS
// ============================================

enum UserRole {
  EMPLOYEE
  MANAGER // Limited admin: can view employees, events, and conference rooms
  ADMIN // Full admin access
  FOOD_COMMITTEE // Food committee: can only manage food vendors, menus, and orders
}

enum ContributionStatus {
  PENDING
  COMPLETED
  FAILED
}

enum EventType {
  BIRTHDAY
  FUNERAL
  CHILDBIRTH
  MARRIAGE
  OTHER
  TEAM_BUILDING
  TRAINING
  MEETING
  WORKSHOP
  CONFERENCE
  TOWN_HALL
  CELEBRATION
}

enum EventCategory {
  WELFARE // Welfare events (birthdays, funerals, etc.)
  COMPANY // Company events (meetings, training, etc.)
}

enum EventStatus {
  ACTIVE
  ARCHIVED
}

enum AttendeeStatus {
  PENDING
  ACCEPTED
  DECLINED
  MAYBE
}

enum BookingStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum ExpenseType {
  BIRTHDAY
  FUNERAL
  MARRIAGE
  CHILDBIRTH
  EMPLOYEE_DEPARTURE
  OTHER
}

enum ExpenseStatus {
  PENDING
  APPROVED
  REJECTED
}

enum NotificationType {
  EVENT_UPCOMING // Event happening soon
  EVENT_ACTIVE // Event is currently active
  EVENT_CREATED // New event created
  CONTRIBUTION_ADDED // New contribution recorded
  EXPENSE_ADDED // New expense recorded
  REMINDER // General reminder to check the app
  ANNOUNCEMENT // General announcement
  ROOM_BOOKING_CREATED // Conference room booking notification
  ROOM_BOOKING_PENDING // Conference room booking pending approval (for approvers)
  ROOM_BOOKING_APPROVED // Conference room booking approved (for requester)
  ROOM_BOOKING_REJECTED // Conference room booking rejected (for requester)
  FOOD_MENU_PUBLISHED // New weekly menu available
  FOOD_SELECTION_REMINDER // Reminder to make selections
  FOOD_SELECTION_CONFIRMED // Confirmation of selections
  FOOD_SELECTION_DEADLINE // Deadline approaching
}

enum MenuStatus {
  DRAFT // Being created by committee
  PUBLISHED // Published, employees can select
  CLOSED // Selection period ended
  SENT // Orders sent to vendor
}

enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
}

// ============================================
// MODELS
// ============================================

model User {
  id                     String                  @id @default(cuid())
  email                  String                  @unique
  name                   String
  department             String?
  password               String                  @default("")
  role                   UserRole                @default(EMPLOYEE)
  isActive               Boolean                 @default(true) // Track if employee is active or has resigned
  isContributor          Boolean                 @default(true) // Track if employee contributes to the welfare fund
  canApproveBookings     Boolean                 @default(false) // Permission to approve/reject conference room bookings
  dateOfBirth            DateTime? // Birthday for automatic birthday tracking
  exitDate               DateTime? // Date when employee left the company
  welfareContributionsBeforeExit Float? // Total welfare contributions before leaving
  contributions          Contribution[]
  events                 Event[]
  expenses               Expense[]
  notifications          Notification[]
  eventAttendees         EventAttendee[]
  conferenceRoomBookings ConferenceRoomBooking[]
  foodSelections         FoodSelection[]
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @default(now())

  emailVerified Boolean
  image         String?
  sessions      Session[]
  accounts      Account[]

  @@map("users")
}

model Contribution {
  id        String             @id @default(cuid())
  userId    String
  user      User               @relation(fields: [userId], references: [id])
  amount    Float
  month     DateTime
  year      Int
  quarter   Int
  status    ContributionStatus @default(PENDING)
  createdAt DateTime           @default(now())
  updatedAt DateTime           @default(now())

  // Indexes for faster aggregation
  @@index([userId, year, month])
  @@index([year, quarter])
  @@map("contributions")
}

model Event {
  id                    String          @id @default(cuid())
  userId                String
  user                  User            @relation(fields: [userId], references: [id])
  type                  EventType
  category              EventCategory   @default(WELFARE) // Differentiate between welfare and company events
  title                 String
  start                 DateTime
  end                   DateTime
  year                  Int
  month                 Int
  quarter               Int
  description           String?
  location              String?
  status                EventStatus     @default(ACTIVE)
  emailNotificationSent Boolean         @default(false) // Track if notification email was sent
  maxAttendees          Int? // For company events with limited capacity
  isRecurring           Boolean         @default(false) // Support for recurring events
  recurrencePattern     String? // JSON string: {frequency: 'daily'|'weekly'|'monthly', interval: number, endDate: Date}
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @default(now())
  attendees             EventAttendee[]

  // Indexes for faster querying and aggregation
  @@index([type, year, month])
  @@index([year, quarter])
  @@index([category, status])
  @@map("events")
}

model EventAttendee {
  id          String         @id @default(cuid())
  eventId     String
  event       Event          @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId      String
  user        User           @relation(fields: [userId], references: [id])
  status      AttendeeStatus @default(PENDING)
  respondedAt DateTime?
  createdAt   DateTime       @default(now())

  @@unique([eventId, userId])
  @@index([userId, status])
  @@map("event_attendees")
}

model ConferenceRoom {
  id          String                  @id @default(cuid())
  name        String                  @unique
  capacity    Int
  location    String?
  amenities   String? // JSON array: ['Projector', 'Whiteboard', 'Video Conference']
  isActive    Boolean                 @default(true)
  description String?
  createdAt   DateTime                @default(now())
  updatedAt   DateTime                @default(now())
  bookings    ConferenceRoomBooking[]

  @@map("conference_rooms")
}

model ConferenceRoomBooking {
  id              String         @id @default(cuid())
  roomId          String
  room            ConferenceRoom @relation(fields: [roomId], references: [id])
  userId          String
  user            User           @relation(fields: [userId], references: [id])
  title           String
  description     String?
  start           DateTime
  end             DateTime
  status          BookingStatus  @default(PENDING) // Requires approver approval
  purpose         String?
  attendeeCount   Int?
  rejectionReason String? // Reason for rejection if status is REJECTED
  approvedBy      String? // User ID of approver who approved/rejected
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @default(now())

  @@index([roomId, start, end])
  @@index([userId, status])
  @@index([start, end, status])
  @@map("conference_room_bookings")
}

model Expense {
  id          Int           @id @default(autoincrement())
  type        ExpenseType
  amount      Float
  date        DateTime
  recipient   String
  description String?
  approvedBy  String? // Admin who approved the expense
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @default(now())
  status      ExpenseStatus @default(APPROVED)
  userId      String? // Optional link to related user
  user        User?         @relation(fields: [userId], references: [id])
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime
  updatedAt DateTime
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime
  updatedAt             DateTime

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime?
  updatedAt  DateTime?

  @@map("verification")
}

model Policy {
  id        String   @id @default(cuid())
  title     String
  slug      String   @unique // URL-friendly identifier
  content   String   @db.Text // Store HTML or Markdown content
  version   Int      @default(1)
  isActive  Boolean  @default(true)
  updatedBy String? // Email of admin who updated
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("policies")
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      NotificationType
  title     String
  message   String
  linkUrl   String? // Optional link to relevant page
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())

  // Optional references to related entities
  eventId        String?
  contributionId String?
  expenseId      Int?

  @@index([userId, isRead])
  @@index([createdAt])
  @@map("notifications")
}

// ============================================
// FOOD ORDERING MODELS
// ============================================

model FoodVendor {
  id          String           @id @default(cuid())
  name        String           @unique
  contactName String?
  phone       String?
  email       String?
  description String?
  isActive    Boolean          @default(true)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @default(now())
  menus       WeeklyFoodMenu[]
  foods       Food[]

  @@map("food_vendors")
}

model Food {
  id             String         @id @default(cuid())
  name           String
  description    String?
  price          Float?
  category       String? // e.g., "Main Course", "Soup", "Rice Dish", etc.
  vendorId       String
  vendor         FoodVendor     @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  isSpecialOrder Boolean        @default(false) // For special dietary needs (e.g., veggie-only orders)
  isActive       Boolean        @default(true)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @default(now())
  menuItems      FoodMenuItem[]

  @@index([vendorId])
  @@index([isActive])
  @@index([isSpecialOrder])
  @@map("foods")
}

model WeeklyFoodMenu {
  id                 String          @id @default(cuid())
  vendorId           String
  vendor             FoodVendor      @relation(fields: [vendorId], references: [id])
  weekStartDate      DateTime // Monday of the week
  weekEndDate        DateTime // Friday of the week
  isActive           Boolean         @default(true)
  selectionOpenDate  DateTime // When employees can start selecting
  selectionCloseDate DateTime // Deadline for selections
  status             MenuStatus      @default(DRAFT)
  notificationSent   Boolean         @default(false) // Track if publication notification was sent
  reminderSent       Boolean         @default(false) // Track if reminder was sent
  createdBy          String // User ID of creator
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @default(now())
  menuItems          FoodMenuItem[]
  selections         FoodSelection[]

  @@index([vendorId, weekStartDate])
  @@index([status, selectionCloseDate])
  @@map("weekly_food_menus")
}

model FoodMenuItem {
  id           String          @id @default(cuid())
  menuId       String
  menu         WeeklyFoodMenu  @relation(fields: [menuId], references: [id], onDelete: Cascade)
  foodId       String? // Reference to Food model (optional for backward compatibility)
  food         Food?           @relation(fields: [foodId], references: [id])
  dayOfWeek    DayOfWeek
  itemName     String // "Jollof with Chicken" - kept for backward compatibility
  description  String?
  price        Float? // Optional pricing
  isAvailable  Boolean         @default(true)
  displayOrder Int             @default(0) // For ordering items in dropdown
  createdAt    DateTime        @default(now())
  selections   FoodSelection[]

  @@index([menuId, dayOfWeek, displayOrder])
  @@index([foodId])
  @@map("food_menu_items")
}

model FoodSelection {
  id         String         @id @default(cuid())
  menuId     String
  menu       WeeklyFoodMenu @relation(fields: [menuId], references: [id], onDelete: Cascade)
  menuItemId String? // Null if "No Selection"
  menuItem   FoodMenuItem?  @relation(fields: [menuItemId], references: [id])
  userId     String
  user       User           @relation(fields: [userId], references: [id])
  dayOfWeek  DayOfWeek
  notes      String? // Special requests (e.g., "No onions please")
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @default(now())

  @@unique([menuId, userId, dayOfWeek]) // One selection per user per day per menu
  @@index([menuId, dayOfWeek])
  @@index([userId])
  @@map("food_selections")
}
